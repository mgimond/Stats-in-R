{
  "hash": "302b280f5923e29d8f95ef49a3d786d7",
  "result": {
    "markdown": "---\ntitle: \"Logistic regression\"\n---\n\n\n*Last modified on 2022-09-12*\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n-----\n\nPackages used in this tutorial:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2) # Used for plotting data\nlibrary(dplyr)   # Used for data manipulation\nlibrary(rms)     # Used to extract p-value from logistic model\n```\n:::\n\n\nAnother package used in this tutorial is `gdata`, but its function will be called directly from the package (e.g. `gdata::mapLevels`) in section 2.\n\n# Introduction\n\nWe'll be making use of median per-capita income data aggregated at the county level for the state of Maine. We will focus on the relationship between income and whether or not the county is on the coast.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load dataset\ndat <- read.csv(\"http://mgimond.github.io/Stats-in-R/Data/Income_and_education.csv\", stringsAsFactors = TRUE)\n\n# Limit the dataset to the two columns of interest\ndf <- select(dat, Coast, Income = Per.capita.income )\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Coast Income\n1     no  23663\n2     no  20659\n3    yes  32277\n4     no  21595\n5    yes  27227\n6     no  25023\n7    yes  26504\n8    yes  28741\n9     no  21735\n10    no  23366\n11    no  20871\n12   yes  28370\n13    no  21105\n14   yes  22706\n15   yes  19527\n16   yes  28321\n```\n:::\n:::\n\n\nOne approach to exploring this dataset is to see *how* per capita income varies as a function of the county's coastal status (i.e. whether or not the county borders the ocean or not). A t-test statistic could be used to assess if incomes differ between coastal and non-coastal communities.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-3-1.png){width=240}\n:::\n:::\n\n\nOr, if one wanted to model that relationship, a [categorical regression analysis](regression.html#4_including_categorical_predictor_variables) could be implemented.\n\nBut what if we are interested in flipping the relationship? In other words, what if we wanted to see how the coastal status of a county related to per capita income? More specifically, what if we wanted to see if county level income could predict whether a county is on the coast or not. Visually, this relationship would look like:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-4-1.png){width=240}\n:::\n:::\n\n\nThis does not look like a *typical* scatter plot one sees in a regression analysis, but the relationship we are exploring is similar in concept--i.e. we are seeking a model of the form `Y = a + bX`. We could, of course, fit a `linear` model to the data as follows:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-5-1.png){width=240}\n:::\n:::\n\n\nThe model to the above fit is of the form *Coast = -1.6 + 8.7e-05 Income*. Now, you may see a couple of issues with this model. For starters, the model implies that there are `coast` values other than `yes` and `no` (e.g. what does the model return for an income value of $24,000?). In fact, the model is treating `coast` as a numeric value where `no` is coded as `0` (no probability) and `yes` is coded as `1` (maximum probability). This makes sense when you re-frame the question along the lines of *what is the probability that the county is on the coast given the county's median per capita income?*\n\nAnother problem with the above model is that the straight line does a very poor job in *fitting* the data and, if we are treating the `coast` axis as a probability limited to the range of 0 and 1, the model implies that we can have a probability greater than `1` (e.g. and income value of $32,000 suggests a probability of about 1.17). A workaround is to fit a different model--one that is bounded by the minimum and maximum probabilities. Such a shape is called a **logistic curve**.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-6-1.png){width=240}\n:::\n:::\n\n\n\n\n# The logistic regression model\n\nThe logistic regression model can be presented in one of two ways:\n\n\n$$\nlog(\\frac{p}{1-p}) = b_0 + b_1 x\n$$\n\n\nor, solving for `p` (and noting that the `log` in the above equation is the *natural* log) we get,\n\n\n$$\np = \\frac{1}{1+e^{-(b_0 + b_1 x)}}\n$$\n\n\nwhere `p` is the probability of `y` occurring given a value `x`. In our example this translates to the probability of a county being on the coast given its median per capita income value. In the first equation, fraction $\\frac{p}{1-p}$ is referred to as the **odds ratio** which gives us the odds in favor of a `yes` (or `1` when represented using binomial values). The log of the *odds ratio*, $log(\\frac{p}{1-p})$, is referred to as the **logit**. Note that the probability can be computed from the odds ratio as $\\frac{odds}{1 + odds}$. Note too that there is not error term as is the case with a linear regression model. \n\nWhereas the linear regression parameters are estimated using the least-squares method, the logistic regression model parameters are estimated using the **maximum-likelihood** method. For our dataset, these parameters can be estimated in R using the `glm()` function as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM1 <- glm(Coast ~ Income, df, family = binomial)\nM1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:  glm(formula = Coast ~ Income, family = binomial, data = df)\n\nCoefficients:\n(Intercept)       Income  \n-12.2177062    0.0005048  \n\nDegrees of Freedom: 15 Total (i.e. Null);  14 Residual\nNull Deviance:\t    22.18 \nResidual Deviance: 14.81 \tAIC: 18.81\n```\n:::\n:::\n\n\nThus, our model looks like:\n\n\n$$\nP_{coast} = \\frac{1}{1+e^{-(-12.2 + 0.0005 Income)}}\n$$\n\n\nwhere $P_{coast}$ is the probability of a county being on the coast. To see what the relationship looks like for a range of income values, we can use the `predict()` function as follows:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a range of income values (we'll cover a wider range then the dataset)\n# The range of values must be saved in a data frame and must have the same column\n# name as that given in the original dataset\nM.df       <- data.frame(Income = seq(10000, 40000, 1000))\n\n#Predict the Coast values (as a probability) using the above data\nM.df$Coast <- predict(M1, newdata=M.df, type=\"response\")\n\n# Plot the modeled probability values\nggplot(M.df, aes(x=Income, y=Coast)) + geom_line()\n```\n\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-8-1.png){width=240}\n:::\n:::\n\n\nNote how the logistic regression model converted the categorical variable `Coast` into a numeric one by assigning `0` to `no` and `1` to `yes`.\n\nA simpler way to plot the model is to make use of `ggplot`'s `stat_smooth` function. However, this will require that we convert the `Coast` factor to numeric values manually since `ggplot` will not do this for us automatically like `glm`. One quick way to do this is to wrap the `Coast` factor with `as.numeric`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(df$Coast)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 1 1 2 1 2 1 2 2 1 1 1 2 1 2 2 2\n```\n:::\n:::\n\n\nInstead of seeing `yes`'s and `no`'s, we now have numbers (`1` and `2`). But which number is mapped to which factor? One easy way to map the levels is to use the `mapLevels` function from the package `gdata`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngdata::mapLevels(df$Coast)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n no yes \n  1   2 \n```\n:::\n:::\n\n\nThe label `no` is mapped to `1` and the label `yes` is mapped to `2`.\n\nHowever, since we are modeling the probability as a fraction that ranges from `0` to `1` we will need to subtract `1` from the converted values as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.numeric(df$Coast) - 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] 0 0 1 0 1 0 1 1 0 0 0 1 0 1 1 1\n```\n:::\n:::\n\n\n\nSo the label `no` is now mapped to `0` and the label `yes` is now mapped to `1`.\n\nNext, we'll plot the values while making sure to map the numeric representation of `Coast` to the y-axis (and not the x-axis).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x=Income, y=as.numeric(df$Coast) - 1)) + \n  geom_point(alpha=.5) +\n  stat_smooth(method=\"glm\", se=FALSE, method.args = list(family=binomial)) + \n  ylab(\"Coast\") \n```\n\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-12-1.png){width=240}\n:::\n:::\n\n\nThe logistic curve does not follow the complete sigmoid shape when limited to the original `Income` range. To see the full shape, we can increase the x-axis range using `xlim`, but this will also require that we instruct `stat_smooth` to extend the logistic curve to the new x-axis range by setting `fullrange` to `TRUE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(df, aes(x=Income, y=as.numeric(df$Coast) - 1)) + \n  geom_point(alpha=.5) +\n  stat_smooth(method=\"glm\", se=FALSE, fullrange=TRUE, \n              method.args = list(family=binomial)) + \n  ylab(\"Coast\") + xlim(10000, 40000)\n```\n\n::: {.cell-output-display}\n![](Logistic_files/figure-html/unnamed-chunk-13-1.png){width=240}\n:::\n:::\n\n\n\n# Assessing the fit with a pseudo R^2^\n\n> Note that even though many statistical software will compute a pseudo-R^2^ for logistic regression models, this measure of fit is not directly comparable to the R^2^ computed for linear regression models. In fact, some statisticians recommend avoiding publishing R^2^ since it can be misinterpreted in a logistic model context.\n\nTo assess how well a logistic model fits the data, we make use of the **log-likelihood** method (this is similar to the Pearson's correlation coefficient used with linear regression models). A *large* log-likelihood statistic indicates a poor fit (similar in idea to a large residual sum of squares statistic for a linear model). What we seek, therefore, is a *small* log-likelihood statistic. What constitutes a small or large statistic is determined by the log likelihood statistic of a base model (aka *null* model) where *none* of the predictive terms are added to he equation, i.e.:\n\n\n$$\np_{null} = \\frac{1}{1+e^{-(b_0)}}\n$$\n\n\nIn our working example, the log-likelihood statistic (often labeled as **-2LL** in some statistical packages) for the null model is,\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM1$null.deviance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 22.18071\n```\n:::\n:::\n\n\nWhat we want is -2LL for the full model (i.e. the model with the `Income` predictor variable) to be smaller than that of the null model. To extract -2LL from the model, type:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nM1$deviance\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 14.80722\n```\n:::\n:::\n\n\nThis value is smaller than that of the null model--a good thing!\n\nThe difference between both log-likelihood values is referred to as the **model Chi-square**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodelChi <- M1$null.deviance - M1$deviance\n```\n:::\n\n\nDividing the model Chi-square by the null log-likelihood value gives us one measure of the **pseudo R-square** (note that there is no exact way to compute the R-square value with a logistic regression model).\n\n\n::: {.cell}\n\n```{.r .cell-code}\npseudo.R2 <- modelChi / M1$null.deviance\npseudo.R2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.3324281\n```\n:::\n:::\n\n\nIn this working example, the model can account for 33.2% of the variability in the `Coast` variable. This pseudo R-square calculation is referred to as the **Hosmer and Lemeshow** R-square.\n\n## Alternative pseudo R^2^\n\nHere, we'll make use of the `rms` package's `lrm` function to compute another form of the pseudo R^2^ called the **Nagelkerke R^2^**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlrm(Coast ~ Income, df)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLogistic Regression Model\n \n lrm(formula = Coast ~ Income, data = df)\n \n                     Model Likelihood    Discrimination    Rank Discrim.    \n                           Ratio Test           Indexes          Indexes    \n Obs          16    LR chi2      7.37    R2       0.492    C       0.828    \n  no           8    d.f.            1    R2(1,16) 0.329    Dxy     0.656    \n  yes          8    Pr(> chi2) 0.0066    R2(1,12) 0.412    gamma   0.656    \n max |deriv| 0.4                         Brier    0.143    tau-a   0.350    \n \n           Coef     S.E.   Wald Z Pr(>|Z|)\n Intercept -12.2176 5.7646 -2.12  0.0341  \n Income      0.0005 0.0002  2.10  0.0355  \n \n```\n:::\n:::\n\n\nNote how this value of 0.49 differs from that of the *Hosmer and Lemeshow* R^2^ whose value is 0.33.\n\n# Assessing the significance\n\n## Model significance\n\nA p-value for the logistic model can be approximated (note that it is difficult to associate an exact p-value with a logistic regression model).\n\nFirst, pull the the difference in degrees of freedom between the null and full model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nChidf <- M1$df.null - M1$df.residual\n```\n:::\n\n\nThen, compute the p-value using the chi-square statistic. This pseudo p-value is also called the **likelihood ratio p-value**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchisq.prob <- 1 - pchisq(modelChi, Chidf)\nchisq.prob\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.006619229\n```\n:::\n:::\n\n\nIf the p-value is small then we can reject the null hypothesis that the current model does not improve on the base model. Here, the p-value is 0.01 suggesting that the model is a significant improvement over the base model.\n\n\n## Parameter significance \n\nIf we want to assess the significance of a parameter as it compares to the base model simply wrap the model object with the `summary` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(M1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = Coast ~ Income, family = binomial, data = df)\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-1.3578  -0.6948  -0.1863   0.5207   2.2137  \n\nCoefficients:\n               Estimate  Std. Error z value Pr(>|z|)  \n(Intercept) -12.2177062   5.7646456  -2.119   0.0341 *\nIncome        0.0005048   0.0002401   2.102   0.0355 *\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 22.181  on 15  degrees of freedom\nResidual deviance: 14.807  on 14  degrees of freedom\nAIC: 18.807\n\nNumber of Fisher Scoring iterations: 5\n```\n:::\n:::\n\n\nThe `Income` coefficient p-value is 0.036.  \n\n# Multi-variable model\n\nSo far, we've worked with a single variable model. We can augment the model by adding more variables. For example, we will add the fraction of the population that has attained a bachelor's degree to the model (we'll ignore the possibility of co-dependence between variables for pedagogical sake).\n\nThe entire workflow follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Grab variables of interest\ndf2 <- select(dat, Coast, Income = Per.capita.income, Edu = Fraction.with.Bachelor.s.or.greater)\n\n# Run regression model\nM2 <- glm(Coast ~ Income + Edu, df2, family = binomial)\n\n# Compute pseudo R-square\nmodelChi <- M2$null.deviance - M2$deviance\npseudo.R2 <- modelChi / M2$null.deviance\npseudo.R2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5422743\n```\n:::\n\n```{.r .cell-code}\n# Compute the pseudo p-value\nChidf <- M2$df.null - M2$df.residual\nmodelChi <- M2$null.deviance - M2$deviance\n1 - pchisq(modelChi, Chidf)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.002444256\n```\n:::\n\n```{.r .cell-code}\n# Assess each parameter's significance\nsummary(M2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = Coast ~ Income + Edu, family = binomial, data = df2)\n\nDeviance Residuals: \n     Min        1Q    Median        3Q       Max  \n-1.52529  -0.22960  -0.04039   0.37393   1.83053  \n\nCoefficients:\n              Estimate Std. Error z value Pr(>|z|)\n(Intercept) -5.9978478  6.8723294  -0.873    0.383\nIncome      -0.0004927  0.0005829  -0.845    0.398\nEdu         73.8296049 46.8728758   1.575    0.115\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 22.181  on 15  degrees of freedom\nResidual deviance: 10.153  on 13  degrees of freedom\nAIC: 16.153\n\nNumber of Fisher Scoring iterations: 6\n```\n:::\n:::\n\n\nNote the change in the `Income` coefficient p-value when adding another variable that may well be explaining the same variability in `Coast` (i.e. `Income` and `Edu` are very likely correlated).\n\n\n-----\n\n**Session Info**:\n\n\n::: {.cell-output-display}\n**R version 4.2.1 (2022-06-23 ucrt)**\n\n**Platform:** x86_64-w64-mingw32/x64 (64-bit) \n\n\n**attached base packages:** \n_stats_, _graphics_, _grDevices_, _utils_, _datasets_, _methods_ and _base_\n\n**other attached packages:** \n_rms(v.6.3-0)_, _SparseM(v.1.81)_, _Hmisc(v.4.7-1)_, _Formula(v.1.2-4)_, _survival(v.3.3-1)_, _lattice(v.0.20-45)_, _dplyr(v.1.0.9)_ and _ggplot2(v.3.3.6)_\n\n**loaded via a namespace (and not attached):** \n_jsonlite(v.1.8.0)_, _splines(v.4.2.1)_, _gtools(v.3.9.3)_, _assertthat(v.0.2.1)_, _latticeExtra(v.0.6-30)_, _pander(v.0.6.5)_, _yaml(v.2.3.5)_, _pillar(v.1.8.1)_, _backports(v.1.4.1)_, _quantreg(v.5.94)_, _glue(v.1.6.2)_, _digest(v.0.6.29)_, _RColorBrewer(v.1.1-3)_, _checkmate(v.2.1.0)_, _colorspace(v.2.0-3)_, _sandwich(v.3.0-2)_, _htmltools(v.0.5.3)_, _Matrix(v.1.4-1)_, _pkgconfig(v.2.0.3)_, _purrr(v.0.3.4)_, _mvtnorm(v.1.1-3)_, _scales(v.1.2.1)_, _gdata(v.2.18.0.1)_, _jpeg(v.0.1-9)_, _MatrixModels(v.0.5-0)_, _htmlTable(v.2.4.1)_, _tibble(v.3.1.8)_, _mgcv(v.1.8-40)_, _generics(v.0.1.3)_, _farver(v.2.1.1)_, _ellipsis(v.0.3.2)_, _TH.data(v.1.1-1)_, _withr(v.2.5.0)_, _nnet(v.7.3-17)_, _cli(v.3.3.0)_, _magrittr(v.2.0.3)_, _deldir(v.1.0-6)_, _polspline(v.1.1.20)_, _evaluate(v.0.16)_, _fansi(v.1.0.3)_, _nlme(v.3.1-157)_, _MASS(v.7.3-57)_, _foreign(v.0.8-82)_, _tools(v.4.2.1)_, _data.table(v.1.14.2)_, _lifecycle(v.1.0.1)_, _multcomp(v.1.4-20)_, _stringr(v.1.4.1)_, _interp(v.1.1-3)_, _munsell(v.0.5.0)_, _cluster(v.2.1.3)_, _compiler(v.4.2.1)_, _rlang(v.1.0.4)_, _grid(v.4.2.1)_, _rstudioapi(v.0.14)_, _htmlwidgets(v.1.5.4)_, _base64enc(v.0.1-3)_, _labeling(v.0.4.2)_, _rmarkdown(v.2.16)_, _gtable(v.0.3.0)_, _codetools(v.0.2-18)_, _DBI(v.1.1.3)_, _R6(v.2.5.1)_, _gridExtra(v.2.3)_, _zoo(v.1.8-10)_, _knitr(v.1.40)_, _fastmap(v.1.1.0)_, _utf8(v.1.2.2)_, _stringi(v.1.7.8)_, _Rcpp(v.1.0.9)_, _vctrs(v.0.4.1)_, _rpart(v.4.1.16)_, _png(v.0.1-7)_, _tidyselect(v.1.1.2)_ and _xfun(v.0.32)_\n:::\n",
    "supporting": [
      "Logistic_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}